import ROOT
from ROOT import *
import numpy as np
import math
import os
from array import array

uncertainty_count_factor = 0.1 #10% background uncertainty for the significance
#variable = "RecoDiJet_delta_R"
variable_list = [
    ["RecoElectron_lead_e", "Reco lead electron energy [GeV]"], #variable name in histo[0], axis title[1]
    ["RecoDiJet_delta_R", "Reco di-jet #Delta R [Rad.]"],
    ["RecoDiJet_angle", "Reco di-jet #Psi [Rad.]"],
    ["RecoElectron_LeadJet_delta_R", "Reco lead jet #DeltaR [Rad.]"],
    ["RecoElectron_SecondJet_delta_R", "Reco second jet #Delta R [Rad.]"],
    ["RecoElectron_DiJet_delta_R","Reco electron di-jet #Delta R [Rad.]"],
    ["RecoLeadElectron_Pmiss_delta_theta", "Reconstructed electron missing momentum angle #theta [Rad.]"],
    ["RecoElectronTrack_absD0sig", "Reco electron |d_{0}| [mm] sig"],
    ["RecoElectronTrack_absD0cov", "Reco electron |d_{0}| [mm] cov"],
    ["RecoElectronTrack_absD0", "Reco electron |d_{0}| [mm]"],
    ["RecoDiJet_phi", "Reco DiJet #phi [Rad.]"],
    ["RecoMissingEnergy_theta", "Reco Missing Energy #theta [Rad.]"],
    ["RecoMissingEnergy_e", "Reco missing energy [GeV]"],
    ["RecoDiJetElectron_invMass", "Mass [GeV]"] #for invmass of the HNL
]
chosen_variable = variable_list[13] 

significance_directions = ["LR", "RL"]
significance_direction = significance_directions[0]

normalisation = True 
luminosity = 10000 #10 fb^-1 as 1e4 pb^-1
#luminosity = 150000000 #150 ab^-1 as 1.5e8 pb^-1

log_scale = True

#pick your selection
selection = "selMissingEGt12_EleEGt35_AngleLt24_DiJetDRLt3" #all selections

input_dir_bkg = "/afs/cern.ch/work/t/tcritchl/full_background_21Nov_2023/" #bb cc and 4body samples
input_dir_sgl = "/eos/user/t/tcritchl/HNLs/final/" #signals 

output_dir =  "/afs/cern.ch/user/t/tcritchl/testfinal/FCCAnalyses_local/examples/FCCee/bsm/LLPs/DisplacedHNL/HNL_sample_creation/signal_HNLS/SignalvsBackground/testfinalcuts/"

if not os.path.exists(output_dir):
    os.mkdir(output_dir)
    print("Directory ",output_dir," Created ")
else:
    print("Directory ",output_dir," already exists")

file_Zbb = input_dir_bkg + 'p8_ee_Zbb_ecm91_'+selection+'_histo'+'.root'
file_Zcc = input_dir_bkg + 'p8_ee_Zcc_ecm91_' + selection+'_histo'+'.root'
file_4body = input_dir_bkg + 'ejjnu_' + selection+'_histo'+'.root'

file_HNL_20 = input_dir_sgl+'HNL_Dirac_ejj_20GeV_1e-3Ve_'+selection+'_histo'+'.root'
file_HNL_50 = input_dir_sgl+'HNL_Dirac_ejj_50GeV_1e-3Ve_'+selection+'_histo'+'.root'
file_HNL_70 = input_dir_sgl+'HNL_Dirac_ejj_70GeV_1e-3Ve_'+selection+'_histo'+'.root'

###signal 
cross_sections_sgl = [0.0037754195,0.0022683354,0.0009058119722033999] #cross sections calculated by madgraph
total_events_sgl =[1,1,1] #events generated by madgraph
selection_scale_sgl = [7377/100000,4962/100000,3017/100000]
files_list_signal = [
   [file_HNL_20, chosen_variable[0], "20GeV HNL",cross_sections_sgl[0],total_events_sgl[0], selection_scale_sgl[0]],
   [file_HNL_50, chosen_variable[0], "50GeV HNL",cross_sections_sgl[1],total_events_sgl[1], selection_scale_sgl[1]],
   [file_HNL_70, chosen_variable[0], "70GeV HNL",cross_sections_sgl[2],total_events_sgl[2], selection_scale_sgl[2]]
]

###background
cross_sections_bg = [5215.46, 6654.46,0.014] #pb
total_events_bg = [2.640333103799864e-05,6645.46, 0.00036679999999999975] #typically normalised to 1 pb of luminosity
selection_scale_bg = [2/(499786495),1/(438738637),2620/100000]
files_list_bg = [
    [file_Zcc, chosen_variable[0], "Z #rightarrow cc", cross_sections_bg[0], total_events_bg[0], selection_scale_bg[0]],
    [file_Zbb, chosen_variable[0], "Z #rightarrow bb", cross_sections_bg[1], total_events_bg[1], selection_scale_bg[1]],
    [file_4body, chosen_variable[0], "Z #rightarrow e #nu qq", cross_sections_bg[2], total_events_bg[2], selection_scale_bg[2]]
]

legend_list_bg = [f[2] for f in files_list_bg]
ratio_list_bg = [f[2] for f in files_list_bg]

legend_list_signal = [f[2] for f in files_list_signal]
ratio_list_signal = [f[2] for f in files_list_signal]

colors_signal = [ROOT.kMagenta - 7, ROOT.kMagenta - 2, ROOT.kMagenta + 3]
colors_bg = [856, 410, 801, 629, 879, 602, 921, 622]


def make_hist(files_list):
    
    h_list = []
    for f in files_list:
        print("Looking at file", f[2])
        my_file = ROOT.TFile.Open(f[0])  # Open the root file
        print("Getting histogram for variable", f[1])
        hist = my_file.Get(f[1])  # Select the chosen variable from the histo root file

        if normalisation:
            
            # Apply normalization based on cross section, total events, and luminosity, and selection fraction surviving
            cross_section = f[3]  # Cross section in pb
            selection_scale = f[5]
            scaling_factor = selection_scale * ((cross_section * luminosity) / (hist.Integral()))
            hist.Scale(scaling_factor)

        hist.SetDirectory(0)  # Make the chosen histogram independent of the directory

        h_list.append(hist)
        print("Histogram added to h_list")
        my_file.Close()
        print("-----------------------")
    return h_list
    
def make_significance(files_list, n_bins, x_min, x_max, h_list_bg):
    sig_list = []
    for h in files_list:
        sig_hist = ROOT.TH1F("Significance", "Significance", n_bins, x_min, x_max)
        for bin_idx in range(1, n_bins + 1):
            s = h.Integral(bin_idx, bin_idx)
            b = sum(bg_hist.Integral(bin_idx, bin_idx) for bg_hist in h_list_bg)
            sigma = b * uncertainty_count_factor
            significance = 0
            if s + b > 0 and b > 1 and s != 0 and sigma != 0:
                n = s + b
                significance = math.sqrt(abs(
                    2 * (n * math.log((n * (b + sigma**2)) / (b**2 + n * sigma**2)) - (b**2 / sigma**2) * math.log((1 + (sigma**2 * (n - b)) / (b * (b + sigma**2))))
                )))
            sig_hist.SetBinContent(bin_idx, significance)
        sig_list.append(sig_hist)
    return sig_list

def make_cumulative_significance(files_list, n_bins, x_min, x_max, h_list_bg, significance_direction):
    sig_list = []
    for h in files_list:
        sig_hist = ROOT.TH1F("Cumulative Significance", "Cumulative Significance", n_bins, x_min, x_max)
        s_cumulative = 0
        b_cumulative = 0
        sigma_cumulative = b_cumulative * uncertainty_count_factor

        if significance_direction == "LR":
            bin_range = range(1, n_bins + 1)
        elif significance_direction == "RL":
            bin_range = range(n_bins, 0, -1)
        else:
            raise ValueError("Invalid significance_direction. Use 'LR' for left to right or 'RL' for right to left.")

        for bin_idx in bin_range:
            s = h.Integral(bin_idx, bin_idx)
            s_cumulative += s
            b = sum(bg_hist.Integral(bin_idx, bin_idx) for bg_hist in h_list_bg)
            b_cumulative += b
            sigma_cumulative = b_cumulative * uncertainty_count_factor
            significance = 0
            if s + b > 0 and b > 1 and s != 0 and sigma_cumulative != 0:
                n = s_cumulative + b_cumulative
                significance = math.sqrt(abs(
                    2 * (n * math.log((n * (b_cumulative + sigma_cumulative**2)) / (b_cumulative**2 + n * sigma_cumulative**2)) - (b_cumulative**2 / sigma_cumulative**2) * math.log((1 + (sigma_cumulative**2 * (n - b_cumulative)) / (b_cumulative * (b_cumulative + sigma_cumulative**2))))
                )))
            sig_hist.SetBinContent(bin_idx, significance)

        sig_list.append(sig_hist)
    return sig_list     

def max_significance(files_list, n_bins, h_list_bg):
    
    max_sig_list = []
    for h in files_list:
        max_sig_value = 0
        for bin_idx in range(1, n_bins + 1):
            s = h.Integral(bin_idx, bin_idx)
            print(f"signal integral {s}")
            b = sum(bg_hist.Integral(bin_idx, bin_idx) for bg_hist in h_list_bg)
            print(f"b intergal {b}")
            sigma = b * uncertainty_count_factor

            if s + b > 0 and b > 0 and s != 0 and sigma != 0:
                n = s + b
                current_significance = math.sqrt(abs(
                    2 * (n * math.log((n * (b + sigma**2)) / (b**2 + n * sigma**2)) - (b**2 / sigma**2) * math.log((1 + (sigma**2 * (n - b)) / (b * (b + sigma**2))))
                )))

                if current_significance > max_sig_value:
                    max_sig_value = current_significance

        max_sig_list.append((max_sig_value))  # keep the significance value and file name

    return max_sig_list   

h_list_signal = make_hist(files_list_signal)
h_list_bg = make_hist(files_list_bg)
n_bins = h_list_bg[0].GetNbinsX()
x_min = h_list_bg[0].GetXaxis().GetXmin()
x_max = h_list_bg[0].GetXaxis().GetXmax()

h_list_significance = make_significance(h_list_signal, n_bins, x_min, x_max, h_list_bg) #change
sig_list = max_significance(h_list_signal,n_bins,h_list_bg)
print(f"max significance list {sig_list}")
#h_list_cum_significance = make_cumulative_significance(h_list_signal, n_bins, x_min, x_max, h_list_bg, significance_direction)

##just some statistics:
print(f"number of 4body events = {h_list_bg[2].Integral()}")
print(h_list_bg[0].Integral(), 'Number of Z->cc events')
print(h_list_bg[1].Integral(), "Number of Z->bb events")
print(h_list_signal[0].Integral(), "Number of 20 GeV events")
print(h_list_signal[1].Integral(), "Number of 50 GeV events")
print(h_list_signal[2].Integral(), "Number of 70 GeV events")

def make_plot(h_list_signal, h_list_bg, h_list_cum_significance):

    c = ROOT.TCanvas("can", "can", 800, 800)

    # Define margins
    left_margin = 0.1
    right_margin = 0.98
    bottom_margin = 0.1
    top_margin = 0.98

    # Create the main pad
    pad1 = ROOT.TPad("pad1", "pad1", left_margin, bottom_margin, right_margin, top_margin, 21)

    pad1.SetFillColor(0)
    pad1.SetBottomMargin(1.0)
    
    if log_scale == True:
        pad1.SetLogy()
    pad1.SetTickx()
    pad1.SetTicky()
    pad1.Draw()

    leg_bg = ROOT.TLegend(0.15, 0.60, 0.35, 0.75)
    #leg_bg = ROOT.TLegend(0.51, 0.5, 0.71, 0.65)
    leg_bg.SetFillStyle(0)
    leg_bg.SetLineWidth(0)
    
    leg_sig = ROOT.TLegend(0.15, 0.40, 0.35, 0.55)
    #leg_sig = ROOT.TLegend(0.51, 0.3, 0.71, 0.45)
    leg_sig.SetFillStyle(0)
    leg_sig.SetLineWidth(0)

    h_list = h_list_signal + h_list_bg

    h_max = 0
    for ih,h in enumerate(h_list):
        if h.GetMaximum() > h_max:
            h_max = h.GetMaximum()
            h_min = h.GetMinimum()
        h.Sumw2()

    # Create a histogram for the sum of background histograms
    h_sum_bg = h_list_bg[0].Clone()
    h_sum_bg.Reset()
    for h_bg in h_list_bg:
        h_sum_bg.Add(h_bg)

    # Create a histogram for the sum of background and signal histograms
    h_sum_total = h_sum_bg.Clone()
    for h_signal in h_list_signal:
        h_sum_total.Add(h_signal)
   
    # Create a TGraphErrors for the continuous band (1 sigma)
    n_points = h_sum_bg.GetNbinsX()
    x_values = [h_sum_bg.GetXaxis().GetBinCenter(i) for i in range(1, n_points + 1)]
    y_values = [h_sum_bg.GetBinContent(i) for i in range(1, n_points + 1)]
    
    errors_1sigma = [0.1 * value for value in y_values]  # 15% uncertainty for 1 sigma
    errors_2sigma = [0.2 * value for value in y_values]  # 30% uncertainty for 2 sigma

    #gr_band_1sigma = ROOT.TGraphErrors(n_points, array("d", x_values), array("d", y_values), array("d", [0.0] * n_points), array("d", errors_1sigma))

    
    #gr_band_2sigma = ROOT.TGraphErrors(n_points, array("d", x_values), array("d", y_values), array("d", [0.0] * n_points), array("d", errors_2sigma))

    # Draw in the top panel
    pad1.cd()
    
    """
    gr_band_2sigma.SetStats(0)
    gr_band_2sigma.GetXaxis().SetRangeUser(10, 80)
    if not log_scale and not normalisation:
        gr_band_2sigma.GetYaxis().SetTitle("Entries")
    elif log_scale and not normalisation:
        gr_band_2sigma.GetYaxis().SetTitle("Log Entries")
    elif not log_scale and normalisation:
        gr_band_2sigma.GetYaxis().SetTitle("Normalised Entries")
    elif log_scale and normalisation:
        gr_band_2sigma.GetYaxis().SetTitle("Log Normalised Entries")

    gr_band_2sigma.GetXaxis().SetTitleSize(0.03)  # Adjust the text size for X-axis label
    gr_band_2sigma.GetYaxis().SetTitleSize(0.03)  # Adjust the text size for Y-axis label
    gr_band_2sigma.GetXaxis().SetLabelOffset(-1000)
    #h.GetXaxis().SetTitleOffset(1.2)  # Adjust the position of the X-axis label
    gr_band_2sigma.GetYaxis().SetTitleOffset(1.4)  # Adjust the position of the Y-axis label
    gr_band_2sigma.SetMaximum(1.25 * h_max)
    gr_band_2sigma.SetMinimum(0.001)
    gr_band_2sigma.SetFillColor(ROOT.kYellow)  # Adjust the color and transparency as needed
    gr_band_2sigma.Draw('a3')  # 'a2' option connects the points with a line
        
    # Draw the continuous bands
    gr_band_1sigma.GetXaxis().SetRangeUser(10, 80)
    gr_band_1sigma.SetStats(0)
    if not log_scale and not normalisation:
        gr_band_1sigma.GetYaxis().SetTitle("Entries")
    elif log_scale and not normalisation:
        gr_band_1sigma.GetYaxis().SetTitle("Log Entries")
    elif not log_scale and normalisation:
        gr_band_1sigma.GetYaxis().SetTitle("Normalised Entries")
    elif log_scale and normalisation:
        gr_band_1sigma.GetYaxis().SetTitle("Log Normalised Entries")

    gr_band_1sigma.GetXaxis().SetTitleSize(0.03)  # Adjust the text size for X-axis label
    gr_band_1sigma.GetYaxis().SetTitleSize(0.03)  # Adjust the text size for Y-axis label
    gr_band_1sigma.GetXaxis().SetLabelOffset(-1000)
    #h.GetXaxis().SetTitleOffset(1.2)  # Adjust the position of the X-axis label
    gr_band_1sigma.GetYaxis().SetTitleOffset(1.4)  # Adjust the position of the Y-axis label
    gr_band_1sigma.SetMaximum(1.25 * h_max)
    gr_band_1sigma.SetMinimum(0.001)
    gr_band_1sigma.SetFillColor(ROOT.kGreen)  # Adjust the color and transparency as needed
    gr_band_1sigma.Draw('Same3l')  # 'a2' option connects the points with a line

    pad1.RedrawAxis()
    """

    h_sum_total.SetLineColor(ROOT.kBlack)
    h_sum_total.SetLineWidth(2)
    h_sum_total.SetStats(0)
    h_sum_total.GetXaxis().SetRangeUser(10, 80)  # Rescale x-axis range
    if not log_scale and not normalisation:
        h_sum_total.GetYaxis().SetTitle("Entries")
    elif log_scale and not normalisation:
        h_sum_total.GetYaxis().SetTitle("Log Entries")
    elif not log_scale and normalisation:
        h_sum_total.GetYaxis().SetTitle("Normalised Entries")
    elif log_scale and normalisation:
        h_sum_total.GetYaxis().SetTitle("Log Normalised Entries")

    h_sum_total.GetXaxis().SetTitleSize(0.03)  # Adjust the text size for X-axis label
    h_sum_total.GetYaxis().SetTitleSize(0.03)  # Adjust the text size for Y-axis label
    h_sum_total.GetXaxis().SetLabelOffset(0.01)
    h_sum_total.GetXaxis().SetTitleOffset(1.4)  # Adjust the position of the X-axis label
    h_sum_total.GetYaxis().SetTitleOffset(1.4)  # Adjust the position of the Y-axis label
    h_sum_total.SetMaximum(1.25 * h_max)
    h_sum_total.SetMinimum(0.001)
    h_sum_total.Draw('hist same')

    h_sum_bg.SetLineColor(ROOT.kBlue)
    h_sum_bg.SetLineStyle(2)  # Dashed line style
    h_sum_bg.SetLineWidth(2)
    h_sum_bg.SetStats(0)
    h_sum_bg.GetXaxis().SetRangeUser(10, 80)
    if not log_scale and not normalisation:
        h_sum_bg.GetYaxis().SetTitle("Entries")
    elif log_scale and not normalisation:
        h_sum_bg.GetYaxis().SetTitle("Log Entries")
    elif not log_scale and normalisation:
        h_sum_bg.GetYaxis().SetTitle("Normalised Entries")
    elif log_scale and normalisation:
        h_sum_bg.GetYaxis().SetTitle("Log Normalised Entries")

    h_sum_bg.GetXaxis().SetTitleSize(0.03)  # Adjust the text size for X-axis label
    h_sum_bg.GetYaxis().SetTitleSize(0.03)  # Adjust the text size for Y-axis label
    h_sum_bg.GetXaxis().SetTitleOffset(1.4)  # Adjust the position of the X-axis label
    h_sum_bg.GetXaxis().SetLabelOffset(0.01)
    h_sum_bg.GetYaxis().SetTitleOffset(1.4)  # Adjust the position of the Y-axis label
    h_sum_bg.SetMaximum(1.25 * h_max)
    h_sum_bg.SetMinimum(0.001)
    h_sum_bg.Draw('hist same')

    # Draw vertical dashed lines at masses of 20 GeV, 50 GeV, and 70 GeV
    line_20GeV = ROOT.TLine(20, 0, 20, 1.25 * h_max)
    line_50GeV = ROOT.TLine(50, 0, 50, 1.25 * h_max)
    line_70GeV = ROOT.TLine(70, 0, 70, 1.25 * h_max)

    line_20GeV.SetLineStyle(2)  # Dashed line style
    line_50GeV.SetLineStyle(2)  # Dashed line style
    line_70GeV.SetLineStyle(2)  # Dashed line style

    line_20GeV.SetLineColor(ROOT.kRed)
    line_50GeV.SetLineColor(ROOT.kRed)
    line_70GeV.SetLineColor(ROOT.kRed)
    
    line_20GeV.Draw("Same")
    line_50GeV.Draw("Same")
    line_70GeV.Draw("Same")
        
    leg = ROOT.TLegend(0.25, 0.7, 0.45, 0.9)  # Adjust the position and size of the legend
    leg.SetBorderSize(0)
    leg.SetFillStyle(0)
    leg.SetTextSize(0.02)
    
    leg.AddEntry(h_sum_bg, "Background", "l")
    leg.AddEntry(h_sum_total, "Signal + Background", "l")
    
    # Add labels for each line
    label_20GeV = ROOT.TLatex(22.5, 0.00125, "20 GeV, Z= 2.47")
    label_50GeV = ROOT.TLatex(52.5, 0.00125, "50 GeV, Z= 1.56")
    label_70GeV = ROOT.TLatex(72.5, 0.00125, "70 GeV, Z= 0.55")

    label_20GeV.SetTextSize(0.025)
    label_50GeV.SetTextSize(0.025)
    label_70GeV.SetTextSize(0.025)

    label_20GeV.SetTextAngle(90)
    label_50GeV.SetTextAngle(90)
    label_70GeV.SetTextAngle(90)

    label_20GeV.Draw()
    label_50GeV.Draw()
    label_70GeV.Draw()

    pad1.RedrawAxis()
    
    leg.Draw()
    ###top right legends###
    text_title = ROOT.TLatex()
    text_title.SetTextSize(0.04)
    text_title.SetTextFont(42)
    text_title.DrawLatexNDC(0.1, 0.92, "#font[72]{FCCee} Simulation (DELPHES)")
    
    text_selection = ROOT.TLatex()
    text_selection.SetTextSize(0.03)
    text_selection.SetTextFont(42)
    text_selection.DrawLatexNDC(0.50, 0.85, "#font[52]{All selections applied}")

    text_lumi = ROOT.TLatex()
    text_lumi.SetTextSize(0.03)
    text_lumi.SetTextFont(42)
    text_lumi.DrawLatexNDC(0.50, 0.80, "#font[52]{#sqrt{s} = 91 GeV , #int L dt = 10 fb^{-1}}")

    pad1.RedrawAxis()

    if log_scale and normalisation:
        c.SetLogy(log_scale)
        c.SaveAs(output_dir + "BackgroundVSignal_" + selection + chosen_variable[0] + "log_" + "norm" + ".pdf", "R")
    elif log_scale and not normalisation:
        c.SetLogy(log_scale)
        c.SaveAs(output_dir + "BackgroundVSignal_" + selection + chosen_variable[0] + "log" + ".pdf", "R")
    elif normalisation and not log_scale:        
        c.SaveAs(output_dir + "BackgroundVSignal_" + selection + chosen_variable[0] + "norm" + ".pdf", "R")
    else:
        c.SaveAs(output_dir + "BackgroundVSignal_" + selection + chosen_variable[0] + ".pdf", "R")
    
    return

make_plot(h_list_signal, h_list_bg, h_list_significance)